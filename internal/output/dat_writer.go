package output

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"

	"github.com/philogag/peer-banner/internal/config"
	"github.com/philogag/peer-banner/internal/models"
)

// DATWriter handles writing ban lists in various formats
type DATWriter struct {
	format  string
	datFile string
}

// NewDATWriter creates a new DAT writer
func NewDATWriter(cfg *config.OutputConfig) *DATWriter {
	return &DATWriter{
		format:  cfg.Format,
		datFile: cfg.DATFile,
	}
}

// Write writes the detection result to the DAT file
func (w *DATWriter) Write(result *models.DetectionResult, dryRun bool) error {
	var content string

	switch w.format {
	case "peerbanana":
		content = w.formatPeerBanana(result)
	case "plain":
		content = w.formatPlain(result)
	default:
		content = w.formatPeerBanana(result)
	}

	if dryRun {
		fmt.Println("=== Dry Run Mode - No changes written ===")
		fmt.Println("Output would be:")
		fmt.Println(content)
		fmt.Println("=========================================")
		return nil
	}

	// Ensure the directory exists
	dir := filepath.Dir(w.datFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write the file
	if err := os.WriteFile(w.datFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write DAT file: %w", err)
	}

	return nil
}

// formatPeerBanana formats the result in PeerBanana format
func (w *DATWriter) formatPeerBanana(result *models.DetectionResult) string {
	tmpl := `# PeerBanana DAT File
# Generated by qBittorrent Leecher Banner
# Server: {{ .ServerName }}
# Date: {{ .Timestamp }}
# Total Banned: {{ .TotalBanned }}

# Banned IPs
{{- range $ip, $entry := .BannedIPs }}
{{ $entry.IP }}
{{- end }}
`
	return w.executeTemplate(tmpl, result)
}

// formatPlain formats the result in plain IP list format
func (w *DATWriter) formatPlain(result *models.DetectionResult) string {
	var ips []string
	for _, entry := range result.BannedIPs {
		ips = append(ips, entry.IP)
	}
	return joinWithNewline(ips)
}

// executeTemplate executes a template with the result
func (w *DATWriter) executeTemplate(tmplStr string, data interface{}) string {
	tmpl, err := template.New("dat").Parse(tmplStr)
	if err != nil {
		// Fallback to simple formatting
		return fmt.Sprintf("Error formatting template: %v", err)
	}

	var buf string
	err = tmpl.Execute(&stringWriter{&buf}, data)
	if err != nil {
		return fmt.Sprintf("Error executing template: %v", err)
	}

	return buf
}

// stringWriter implements io.Writer for strings.Builder
type stringWriter struct {
	s *string
}

func (w *stringWriter) Write(p []byte) (n int, err error) {
	*w.s += string(p)
	return len(p), nil
}

// joinWithNewline joins strings with newlines
func joinWithNewline(items []string) string {
	if len(items) == 0 {
		return ""
	}
	result := items[0]
	for i := 1; i < len(items); i++ {
		result += "\n" + items[i]
	}
	return result
}

// DATFile returns the path to the DAT file
func (w *DATWriter) DATFile() string {
	return w.datFile
}

// Format returns the current format
func (w *DATWriter) Format() string {
	return w.format
}

// GetStats returns statistics about the ban list
func GetStats(result *models.DetectionResult) string {
	return fmt.Sprintf(
		"Server: %s | Total Peers: %d | Banned: %d | Timestamp: %s",
		result.ServerName,
		result.TotalPeers,
		result.TotalBanned,
		result.Timestamp.Format(time.RFC3339),
	)
}
