package output

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
	"time"

	"github.com/philogag/peer-banner/internal/ban"
	"github.com/philogag/peer-banner/internal/config"
	"github.com/philogag/peer-banner/internal/models"
)

// DATWriter handles writing ban lists in various formats
type DATWriter struct {
	format     string
	datFile    string
	banManager *ban.Manager
}

// NewDATWriter creates a new DAT writer
func NewDATWriter(cfg *config.OutputConfig, banManager *ban.Manager) *DATWriter {
	return &DATWriter{
		format:     cfg.Format,
		datFile:    cfg.DATFile,
		banManager: banManager,
	}
}

// Write writes the detection result to the DAT file
func (w *DATWriter) Write(result *models.DetectionResult, dryRun bool) error {
	// Get all active bans from manager (including persistent bans from previous runs)
	var activeBans []*models.BannedIP
	if w.banManager != nil {
		activeBans = w.banManager.GetActiveBans()
	} else {
		// Fallback to result-based (old behavior)
		activeBans = make([]*models.BannedIP, 0, len(result.BannedIPs))
		for _, b := range result.BannedIPs {
			activeBans = append(activeBans, b)
		}
	}

	var content string

	switch w.format {
	case "peerbanana":
		content = w.formatPeerBanana(activeBans, result.Timestamp)
	case "plain":
		content = w.formatPlain(activeBans)
	default:
		content = w.formatPeerBanana(activeBans, result.Timestamp)
	}

	if dryRun {
		fmt.Println("=== Dry Run Mode - No changes written ===")
		fmt.Println("Output would be:")
		fmt.Println(content)
		fmt.Println("=========================================")
		return nil
	}

	// Ensure the directory exists
	dir := filepath.Dir(w.datFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write the file
	if err := os.WriteFile(w.datFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write DAT file: %w", err)
	}

	return nil
}

// formatPeerBanana formats the result in PeerBanana format
func (w *DATWriter) formatPeerBanana(bans []*models.BannedIP, timestamp time.Time) string {
	tmpl := `# PeerBanana DAT File
# Generated by qBittorrent Leecher Banner
# Date: {{ .Timestamp }}
# Total Banned: {{ .Count }}

# Banned IPs
{{- range .Bans }}
{{ .IP }}
{{- end }}
`
	data := struct {
		Bans      []*models.BannedIP
		Count     int
		Timestamp time.Time
	}{
		Bans:      bans,
		Count:     len(bans),
		Timestamp: timestamp,
	}
	return w.executeTemplate(tmpl, data)
}

// formatPlain formats the result in plain IP list format
func (w *DATWriter) formatPlain(bans []*models.BannedIP) string {
	var ips []string
	for _, ban := range bans {
		ips = append(ips, ban.IP)
	}
	return joinWithNewline(ips)
}

// executeTemplate executes a template with the result
func (w *DATWriter) executeTemplate(tmplStr string, data interface{}) string {
	tmpl, err := template.New("dat").Parse(tmplStr)
	if err != nil {
		// Fallback to simple formatting
		return fmt.Sprintf("Error formatting template: %v", err)
	}

	var buf string
	err = tmpl.Execute(&stringWriter{&buf}, data)
	if err != nil {
		return fmt.Sprintf("Error executing template: %v", err)
	}

	return buf
}

// stringWriter implements io.Writer for strings.Builder
type stringWriter struct {
	s *string
}

func (w *stringWriter) Write(p []byte) (n int, err error) {
	*w.s += string(p)
	return len(p), nil
}

// joinWithNewline joins strings with newlines
func joinWithNewline(items []string) string {
	if len(items) == 0 {
		return ""
	}
	result := items[0]
	for i := 1; i < len(items); i++ {
		result += "\n" + items[i]
	}
	return result
}

// DATFile returns the path to the DAT file
func (w *DATWriter) DATFile() string {
	return w.datFile
}

// Format returns the current format
func (w *DATWriter) Format() string {
	return w.format
}

// GetStats returns statistics about the ban list
func GetStats(result *models.DetectionResult) string {
	return fmt.Sprintf(
		"Server: %s | Total Peers: %d | Banned: %d | Timestamp: %s",
		result.ServerName,
		result.TotalPeers,
		result.TotalBanned,
		result.Timestamp.Format(time.RFC3339),
	)
}
